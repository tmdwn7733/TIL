# linux
git bash에서 .ssh로 이동한 다음 aws 퍼블릭 코드(ssh -i "V-lab.pem" ubuntu@ec2-3-114-30-206.ap-northeast-1.compute.amazonaws.com)를 사용해서 ubuntu계정으로 시작을 해야함

## 설명 명령어
1. `man find`
   - 상세 메뉴얼
   - 특정 파일에 (> or >>)을 사용해 결과 내용을 입력할수 있음
2. `find -hlep(find -h, find --h)    `
   - 간략 메뉴얼
   - man find보다 엑기스만 보여주는 것으로 

## 파일시스템 명령어(무조건 외우기)
[리눅스 경로 표시방법]
- `/` : 루트입니다. 시스템의 시작 부분을 의미합니다.
- `~` : 현재 로그인한 유저의 `home` 경로입니다.
  - 내가사용하는 계정의 가장 상위 디렉토리
- `/` : 디렉토리 경로 상에 있는 경우 디렉토리를 구분하는 구분자의 역할을 합니다.
- `..` : 상위 디렉토리를 의미합니다.
- `.` : 현재 디렉토리를 의미합니다.
- `-` : 이전 위치를 의미합니다.
---
1. `pwd`
      - 현재 경로 확인
   - 실행 결과 : `/home/ubuntu`
        - ubuntu는 root을 대체하는 역할
        - 경로: root -> home -> ubuntu
        - 이때 사실상 home 위의 경로는 거의 건드리면 안됨
2. `ll(ls -al)`
   지정한 경로에 있는 모든 파일 및 디렉토리의 목록을 보여줍
   - 실행 결과 : `-rw-r--r-- 1 ubuntu multi     0 Mar 13 16:19 .sudo_as_admin_successful`
     - -rw-r--r-- : 디렉토리명
     - 1 : 디렉토리 안의 파일 개수
     - ubuntu : 사용 계정
     - 0 : 저장용량
     - .은 파일을 숨김처리함
3. `ls`
   - 간단한 목록 확인
4. `mkdir '디렉토리(폴더) 명'`
   - 디렉토리 생성
   - 숨겨진 디렉토리를 생성하려면 폴더명 앞에 .을 붙이기
   - `mkdir -p '폴더 명'` : 하위 디렉토리를 한꺼번에 생성하기 위해 -p 옵션을 넣음
5. `cd '디렉토리명'`
   - 디렉토리 이동
6. `rm '파일 명`
   - 파일 및 디렉토리 삭제
   - 다만 디렉토리를 삭제할때는 -r을 기입
     - `rm -r '디렉토리명'`
7. `chmod`
   - 파일 권한 변경하기
   - ~$ ll을 했을때 나타나는 디렉토리 목록에서 맨앞 10자리를 볼 수 있음
     - 권한 예시 : drwxrwxr-x
       1. `d` : 디렉토리를 의미합니다. 파일인 경우 `-`가 됩니다.
       2. `rwx` : 파일 소유자에 대한 권한을 의미합니다.
       3. `rwx` : 파일 소유자가 속한 그룹에 대한 권한입니다.
       4. `r-x` : 파일 소유자가 속하지 않은 그룹에 대한 권한입니다.
       - d를 제외한 앞쪽 세자리는 같은 그룹을 뒤쪽 6자리는 그룹에 대한 권한을 의미
   - 이진법으로 표시가 됨
     - rwx(읽기 4, 쓰기 2, 실행 1)
        - `---` : 0+0+0=0
        - `--x` : 0+0+1=1
        - `-w-` : 0+2+0=2
        - `-wx` : 0+2+1=3
        - `r--` : 4+0+0=4
        - `r-x` : 4+0+1=5
        - `rw-` : 4+2+0=6
        - `rwx` : 4+2+1=7
    - 만약 dir1 폴더에 대한 권한을 소유자는 읽기,쓰기,실행을 모두할 수 있고(rwx : 7), 같은 그룹내 사용자는 읽기와 쓰기만(rw- : 6), 다른 그룹내의 사용자는 실행에 대한 권한(--x : 1)을 모두 주려면 `chmod 761 '폴더명'`을 실행!
    - 하위 디렉토리까지 다 동일하게 주고 싶으면 `-R` 옵션도 함께 부여
      - `chmod -R 761 '폴더명'`

## 파일 관리 명령어
1. `&&`
   - 두개의 명령어를 동시에 실행 할 수 있음
     - 실행 예시 : `mkdir sample && cd sample`
       - sample파일을 만들고 이동하겠다
2. `touch '파일명'`
   - 비어있는 파일 만들기
3. `cat '파일명'`
   - 파일 내용 출력하기
4. `echo "메시지"`
   - 메시지 출력
   - 특정 파일에 (> or >>)을 사용해 메시지를 입력할수 있음
     - `echo "하이하이" >> newfile`
       - newfile이란 파일에 하이하이라는 메시지를 넣음
     - `>` 는 create or overwrite, `>>`는 create or append   
        - `>` 를 사용하면 내용이 덮어써지고, `>>`를 사용하면 내용을 아랫줄에 추가
5. `head '파일명'` or `tail '파일명'`
   - head 명령어는 파일의 내용의 앞 부분 부터 보여주며, tail은 뒷 부분을 보여줌
   - `-n` 옵션을 이용해 출력할 라인 수를 지정할 수 있음
     - 실행 예시: `head -n 20 '파일명'`   
        -> 위에서부터 20줄 보여줘
6. `mv '위치/파일명' '위치2/파일명'`
   - 파일 이동 및 이름변경
   - 이동 예시
     - `mv sample/newfile sample2/newfile`
   - 이름 변경 예시
     - `mv sample2/newfile sample2/gamja`
7. `cp`
   - 파일 복사
   - 복사하면서 이름도 새로 지정할 수 있음
   - 복사 예시
     - `cp sample2/gamja sample2/goguma`

## 파일 검색
1. `find`
   - 파일 이름을 이용해 찾기
   - 애스터리스크(*)를 이용해 패턴을 지정할 수 있음
   - 실행 예시: `find . -name "sam*"`
     - 파일이름이 sam이으로 시작하는 파일을 찾아줌
2. `grep`
   - 파일 이름 및 파일 내용을 이용해 찾기
   - find와 비슷한 역할을 하지만 find보다 폭 넓은 검색을 지원
   - 실행 예시: `grep -rn "sam*"`
     - 현재 위치에서 sma이라는 문자열이 들어간 파일과 파일 내용을 찾아줌
   - 실행 예시2: `grep -rn "[a-zA-Z]\+tion$" .`
     - 각 라인의 끝이 tion으로 끝나는 내용이 들어있는 파일을 정규식을 통해 찾아줌
3. `wich`
   - 환경 변수의 원래 경로 찾기
   - 만약 가상환경안에서 사용하는 파일을 찾으면
     - /home/ubuntu/miniconda3/envs/spark-env/bin/python
     - 위의 결과처럼 spark-env라는 가상환경안에 python을 찾아줌

## 시스템 명령어
1. `uname`
   - 현재 시스템 정보 알아보기
   - `-a`를 사용해 자세한 정보를 알아볼 수 있음
2. `ps`⭐⭐⭐⭐⭐
   - 프로세스 확인
   - 실행 결과
        ```
        PID TTY          TIME CMD
        1957 pts/1    00:00:00 bash
        3391 pts/1    00:00:00 ps
        ```
     - PID는 프로세스 고유의 아이디(프로세스는 램에 올라와있는 실행중인 것!)
3. `kill`⭐⭐⭐⭐⭐
   - 진행중인 프로세스를 강제로 프로세스를 죽여줌
   - `kill -9 "pid 숫자"`에서 -9는 가장 강력한 시그널
     - -9 시그널(SIGKILL)은 프로세스를 강제로 종료하겠다는 시그널
     - -9 시그널 이외에 -15 시그널(SIGTERM)도 많이 사용됩니다. SIGTERM은 보통 어플리케이션에서 종료 시그널을 받았을 때 현재 처리하고 있는 내용을 다 처리하고 종료하거나 특정 상황에서 강제 종료되는 상황 등을 막기 위해 사용
     - 즉, -9 시그널은 언제든지 강제 종료가 되기 때문에 어플리케이션이 작업 중이던 내용을 다 처리하지 못하고 종료되지만, -15 시그널은 개발자가 시그널을 처리하기 위한 로직(코드)을 구현할 수 있음
   

# 분산 시스템
> 여러대의 컴퓨터를 사용!
## 기본특징
1. Concurrency   
자원은 공유하면서, 리소스내에서 동시에 여러가지 작업을 수행합니다. 동시 실행 자원을 늘려서 처리량을 늘릴 수 있습니다.
2. No Global Clock   
시스템의 각 부분이 비동기식으로 동작합니다. 또한 어떤 한 부분의 상태 때문에 다른 곳에 Lock, Bottleneck 이 걸리면 안됩니다.
3. Independent Failure    
시스템의 한 부분의 실패가 전체 시스템에 영향(장애)을 주면 안됩니다.   
즉, 독립적!

## 분산 시스템의 고려 요소 
운영체제, HW 에 대한 임팩트가 크기 때문에, OS, HW 관계없이 일관된 개발을 하기 위한 언어를 선택
- Java가 가장 대표적임

# 빅데이터 엔지니어링의 개요
Hadoop이 제일 탄탄함.

실시간 데이터를 사용한다면 realtime data를 사용하는 tool을 사용하고
과거 데이터를 하용하려면 betch data를 사용하는 tool을 사용할 수 있음
    - 여기서 과거의 데이터라한다면 pandas라고도 할수 있음. 왜냐면 생각해보면 pandas도 csv와 같은 과거 데이터를 다루기에!
  
data lake는 가공이 되자 않은 데이터가 쌓아놓는것. 그래서 django자체가 데이터 레이크라 할 수 있음. 즉, 이렇게 정리가 안된 애들을 data warehouse에 분류, 정리를 해야함

data warehouse는 데이터의 최소한의 정리만 하는것으로 none값을 정리하거나 필요하면 join을 할 수 있음

다음이 상품화하는과정으로 이러헥 상품이 되는 애들이 모여있는 곳이 data mart임.

마지막으로 상품화가 된 데이터로 분석을 하고 이것저것 할 수 있은것!

그래서 사실 Spark 하나만으로 웬만한 툴은 다 대체할 수 있음. 짱짱맨!

요즘 하둡은 데이터 저장소이기에 툴간의 연결다리? 빅데이터 시스템을 하둡기반으로 구축하는 정도로만 다룸.
즉, 하둡을 해본적이 있냐라는 질문은 하둡기반응로 빅데이터 분석 프로젝트를 해봤냐라는 질문으로 생각하면 됨

## Hadoop
### 하둡의 Master/Worker의 체계가 중요

### 하둡의 변천사 알아보기
- haddop1의 구조
- haddop2
   현실적인 빅데이터의 분석의 구조라 할수 있음
   -  네임노드를 활성화 시켰음. 하지만 활성화할수 잇는 건 하나이기에 standy와 active로 이중관리를 햇음
   -  사장님도 관리를 했음. 또한 사장님이 고객님과 얘기만 하고 모니터링 할수 있는 비서역할(YARN)이 생김. 이 비서가 스케쥴링까지 담당해주면서 이러한 NAME NODE가 여유로워짐
- haddop3
  - 크게 바뀐건 없고 haddop2에서 기능이 몇개 추가된것
  - Java 1.8버전을 지향
    - 1.7버전은 객체지향 프로그래밍을 지원. 즉 레고처럼 하나의 기능을 사용하기 위해 쓰잘데기 없이 class를 만들어야하는 쓸모없는 레고조각이 많아짐
    - 1.8버전부터는 lambda식이 추가되면서 함수형 프로그래밍이 가능해짐. 그래서 쓸데없는 class없이 바로 필요한 함수를 넣을수 있음. 

#